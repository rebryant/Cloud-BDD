# Encoding solutions to matrix multiplication problems
import re

# Brent variables
class BrentVariable:
    symbol = 'a'
    prefix = 'alpha'
    row = 1
    column = 1
    level = 1
    fieldSplitter = None
    namer = {'a':'alpha', 'b':'beta', 'c':'gamma'}
    symbolizer = {'alpha':'a', 'beta':'b', 'gamma':'c'}

    def __init__(self):
        self.fieldSplitter = re.compile('[-\.]')

    def fromName(self, name):
        fields = self.fieldSplitter.split(name)
        self.prefix = fields[0]
        self.symbol = self.symbolizer[self.prefix]
        srow = fields[2]
        self.row = int(srow)
        scol = fields[4]
        self.column = int(scol)
        slevel = fields[-1]
        self.level = int(level)

    def fromSymbol(self, sym, permuteC = False):
        self.symbol = sym[0]
        self.prefix = self.namer[self.symbol]
        self.row = int(sym[1])
        self.column = int(sym[2])
        if permuteC and self.prefix == 'gamma':
            self.row,self.column = self.column,self.row

    # For use in formulas
    def generateName(self):
        var = "%s-r-%d.c-%d.l-%d" % (self.prefix, self.row, self.column, self.level)
        return var

    # For use in displaying scheme
    def generateSymbol(self, permuteC = False):
        sym = self.symbol
        s1 = str(self.row)
        s2 = str(self.col)
        if permuteC:
            s1, s2, = s2, s1
        return sym + s1 + s2

# Describe encoding of matrix multiplication
class MScheme:

    # Matrix dimensions, given as (n1, n2, n3)
    dim = (2, 2, 2)
    # Number of auxilliary variables
    auxCount = 7
    # Encoding of alpha variables
    alphaList = []
    # Encoding of beta variables
    betaList = []
    # Encoding of gamma variables
    gammaList = []

    # scheme is a dict with entries 'alpha', 'beta', 'gamma',
    # each giving lists of lenght auxCount
    def __init__(self, dim = (2,2,2), scheme = None):
        if type(dim) == type(2):
            self.dim = (dim, dim, dim)
        else:
            self.dim = dim
        self.alphaList = []
        self.betaList = []
        self.gammaList = []
        if scheme is not None:
            self.alphaList = scheme['alpha']
            self.auxCount = len(self.alphaList)
            self.betaList = scheme['beta']
            self.gammaList = scheme['gamma']

    # Parse the output generated by a solver
    def parseFromSolver(self, supportNames, bitString):
        supportVars = [BrentVariable().fromName(s) for s in supportNames]
        self.auxCount = 0
        done = False
        while not done:
            lists = {'a':[], 'b':[], 'c':[]}
            lcount = 0
            for i in range(len(bitString)):
                name = supportVars[i]
                var = BrentVariable(name)
                if bitString[i] == '1' and var.level == level:
                    lists[var.symbol].append(var)
                    lcount += 1
            done = lcount == 0
            if not done:
                self.alphaList.append(lists['a'])
                self.betaList.append(lists['b'])
                self.gammaList.append(lists['c'])
                self.auxCount += 1
                
    # Parse from printed solution
    def parseFromWeb(self, str):
        lines = str.split('\n')
        
            
        
        
