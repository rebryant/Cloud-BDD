# Encoding solutions to matrix multiplication problems
import re

# Brent variables
class BrentVariable:
    symbol = 'a'
    prefix = 'alpha'
    row = 1
    column = 1
    level = 1
    fieldSplitter = None
    namer = {'a':'alpha', 'b':'beta', 'c':'gamma'}
    symbolizer = {'alpha':'a', 'beta':'b', 'gamma':'c'}


    def __init__(self, prefix = None, row = None, column = None, level = None):
        if prefix is not None:
            self.prefix = prefix
        if row is not None:
            self.row = row
        if column is not None:
            self.column = column
        if level is not None:
            self.level = level
        self.fieldSplitter = re.compile('[-\.]')

    def fromName(self, name):
        fields = self.fieldSplitter.split(name)
        self.prefix = fields[0]
        self.symbol = self.symbolizer[self.prefix]
        srow = fields[2]
        self.row = int(srow)
        scol = fields[4]
        self.column = int(scol)
        slevel = fields[-1]
        self.level = int(slevel)
        return self

    def fromSymbol(self, sym, permuteC = False):
        self.symbol = sym[0]
        self.prefix = self.namer[self.symbol]
        self.row = int(sym[1])
        self.column = int(sym[2])
        if permuteC and self.prefix == 'gamma':
            self.row,self.column = self.column,self.row
        return self

    # For use in formulas
    def generateName(self):
        var = "%s-r-%d.c-%d.l-%d" % (self.prefix, self.row, self.column, self.level)
        return var

    # For use in displaying scheme
    def generateSymbol(self, permuteC = False):
        sym = self.symbol
        s1 = str(self.row)
        s2 = str(self.column)
        if permuteC:
            s1, s2, = s2, s1
        return sym + s1 + s2

    def __str__(self):
        return self.generateName()

# Describe encoding of matrix multiplication
class MScheme:

    # Matrix dimensions, given as (n1, n2, n3)
    dim = (2, 2, 2)
    # Number of auxilliary variables
    auxCount = 7
    # Encoding of alpha variables
    alphaList = []
    # Encoding of beta variables
    betaList = []
    # Encoding of gamma variables
    gammaList = []
    expressionSplitter = None


    # scheme is a dict with entries 'alpha', 'beta', 'gamma',
    # each giving lists of lenght auxCount
    def __init__(self, dim = (2,2,2), scheme = None):
        if type(dim) == type(2):
            self.dim = (dim, dim, dim)
        else:
            self.dim = dim
        self.alphaList = []
        self.betaList = []
        self.gammaList = []
        self.expressionSplitter = re.compile('[-+]')
        if scheme is not None:
            self.alphaList = scheme['alpha']
            self.auxCount = len(self.alphaList)
            self.betaList = scheme['beta']
            self.gammaList = scheme['gamma']

    # Parse the output generated by a solver
    def parseFromSolver(self, supportNames, bitString):
        supportVars = [BrentVariable().fromName(s) for s in supportNames]
        self.auxCount = 0
        done = False
        level = 1
        while not done:
            lists = {'a':[], 'b':[], 'c':[]}
            lcount = 0
            for i in range(len(bitString)):
                name = supportVars[i]
                var = BrentVariable(name)
                if bitString[i] == '1' and var.level == level:
                    lists[var.symbol].append(var)
                    lcount += 1
            done = lcount == 0
            if not done:
                self.alphaList.append(lists['a'])
                self.betaList.append(lists['b'])
                self.gammaList.append(lists['c'])
                self.auxCount += 1
        return self
                
    # Parse from printed solution
    def parseFromExpression(self, lines):
        self.auxCount = len(lines)
        level = 1
        for line in lines:
            # Remove parentheses
            parts = line.split('*')
            lists = [self.alphaList, self.betaList, self.gammaList]
            for i in range(3):
                p = parts[i]
                # Strip parentheses
                p = p[1:-1]
                # Split with + and -:
                terms = self.expressionSplitter.split(p)
                # Remove empty ones
                terms = [t for t in terms if t != ""]
                # Create variables
                vars = [BrentVariable(level = level).fromSymbol(t, permuteC = True) for t in terms]
                lists[i].append(vars)
            level += 1
        return self
        
    # Generate formula encoding (partial) solution
    def generateConstraints(self, ckt, subset = ['alpha', 'beta', 'gamma']):
        pass
        
strassenFormula = [
    "(a11+a22)*(b11+b22)*(c11+c22)",
    "(a21+a22)*(b11)*(c12+c22)",
    "(a11)*(b12+b22)*(c21+c22)",
    "(a22)*(b21+b11)*(c11+c12)",
    "(a11+a12)*(b22)*(c11+c21)",
    "(a21+a11)*(b11+b12)*(c22)",
    "(a12+a22)*(b21+b22)*(c11)"
    ]
        
